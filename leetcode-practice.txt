13.
// first we want to create an object with the symbols and what they represent
// we loop backwards and query the object
// add branching statements for subtraction methods in roman numerals

// 27 the string === XXIV - adds backwards 
//
var romanToInt = function(s){
  const romanNums = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000
  }
  let result = 0;
  for(let i = 0; i < s.length; i++){
    romanNums[s[i]] < romanNums[s[i + 1]] ? result -= romanNums[s[i]]:
    result += romanNums[s[i]]
  }
    return result;
}

27.
// since space comp is O(1) we can't create another array
// we can just keep track of how many of the vals are in the array
// then subtract it from the length of the array

var removeElement = function(nums, val) {
  let tracker = 0;
  const length = nums.length;
  for(let i = 0; i < length; i++){
    if(nums[i] === val) {
      tracker++
      nums.splice(i, 1)
      i--
    }
  }    
  let result = length - tracker;
  return result;
};
var removeElement = function(nums, val) {
  let tracker = 0;
  for(let i = 0; i < nums.length; i++){
    if(nums[i] === val) {
      nums.splice(i, 1)
      i--
    }
  }    
  return nums.length;
};

21.

var mergeTwoLists = function(l1, l2) {
    let newNode = new ListNode();
    this.head = newNode;
    while(l1 != null && l2 != null){
        if(l1.val < l2.val){
            newNode.next = l1; 
            l1 = l1.next; 
        } else {
            newNode.next = l2;
            l2 = l2.next;
        }
        newNode = newNode.next; //this will move the pointer in our new list forward so we dont overwrite
    }
    if(l1 != null){
        newNode.next = l1; // puts the remainder of l1 nodes inside
    } else {
        newNode.next = l2; // puts the remainder of l2 nodes inside
    }
    return head.next; // .next represents all the upcoming nodes so it returns the entire new list 
};